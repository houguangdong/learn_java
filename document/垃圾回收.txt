垃圾回收器是如何工作的？我现在就简单的介绍一下

首先要明确几点：

Java是在堆上为对象分配空间的

垃圾回收器只跟内存有关，什么IO啊，网络连接啊，管它P事

当可用内存数量较低时，Sun版本的垃圾回收器才会被激活

在垃圾回收器回收垃圾之前，我们先来了解一下Java分配对象的方式，Java的堆更像一个传送带，每分配一个新对象，它就往前移动一格。这意味着对象存储空间的分配速度相当快。Java的“堆指针”只是简单地移动到尚未分配的领域。也就是说，分配空间的时候，“堆指针”只管依次往前移动而不管后面的对象是否还要被释放掉。如果可用内存耗尽之前程序就退出就再好不过了，这样的话垃圾回收器压根就不会被激活。

但是由于“堆指针”只管依次往前移动，那么你肯定会想，总有一天内存会被耗尽，垃圾回收器就开始释放内存。这里有人肯定会问：怎么判断某个对象该被回收呢？答案就是当堆栈或静态存储区没有对这个对象的引用时，就表示程序（员）对这个对象没有兴趣了，它就应该被回收了。有两种方法来知道这个对象有没有被引用：第一种是遍历堆上的对象找引用；第二种是遍历堆栈或静态存储区的引用找对象。前者的实现叫做“引用计数法”，意思就是当有引用连接至对象时，引用计数加1，当引用离开作用域或被置为null时，引用计数减1，这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应该被回收，但引用计数却不为零”的情况。

Java采用的是后者，在这种方式下，Java虚拟机采用一种“自适应”的垃圾回收技术，如何处理找到的存活对象（也就是说不是垃圾），Java有两种方式：

一种是“停止-复制”：理论上是先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全是垃圾。当对象被复制到新堆上时，它们是一个挨着一个的，所以新堆保持紧凑排列（这也是为什么分配对象的时候“堆指针”只管依次往前移动）。然后就可以按前述方法简单、直接地分配内存了。这将导致大量内存复制行为，内存分配是以较大的“块”为单位的。有了块之后，垃圾回收器就可以不往堆里拷贝对象了，直接就可以往废弃的块里拷贝对象了。

另一种是“标记-清扫”：它的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象一个标记。这个过程中不会回收任何对象。只有全部标记完成时，没有标记的对象将被释放，不会发生任何复制工作，所以剩下的堆空间是不连续的，然后垃圾回收器重新整理剩余的对象，使它们是连续排列的。

当垃圾回收器第一次启动时，它执行的是“停止-复制”，因为这个时刻内存有太多的垃圾。然后Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到“标记-清扫”方式；同样，Java虚拟机会跟踪“标记-清扫”效果，要是堆空间出现很多碎片，就会切换到“停止-复制”方式。这就是所谓的“自适应”技术。

其实仔细想一下，“停止-复制”和“标记-清扫”无非就是：“在大量的垃圾中找干净的东西和在大量干净的东西里找垃圾”。不同的环境用不同的方式，这样做完全是为了提高效率，要知道，无论哪种方式，Java都会先暂停程序的运行，所以，垃圾回收器的效率其实是很低的。Java用效率换回了C++没有的垃圾回收器和运行时的灵活，我认为这是明智的选择（虽然它只跟内存有关），随着硬件的飞速发展，我相信，开发时间要比运行效率重要得多！

